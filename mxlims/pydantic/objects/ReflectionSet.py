# generated by mxlims/impl/generate_code.py
#  filename ReflectionSet.py

# NB Literal and UUID have to be imported to avoid pydantic errors
from __future__ import annotations
from pydantic import Field
from typing import Any, Literal, Optional, Union, TYPE_CHECKING
from uuid import UUID, uuid1
from mxlims.impl.MxlimsBase import MxlimsImplementation
from ..core.Dataset import Dataset
from ..data.DatasetData import DatasetData
from ..data.ReflectionSetData import ReflectionSetData
if TYPE_CHECKING:
    from .Crystal import Crystal
    from .DropRegion import DropRegion
    from .MxExperiment import MxExperiment
    from .MxProcessing import MxProcessing
    from .Pin import Pin
    from .PinPosition import PinPosition
    from .PlateWell import PlateWell
    from .WellDrop import WellDrop

class ReflectionSet(ReflectionSetData, DatasetData, Dataset, MxlimsImplementation):
    """MXLIMS pydantic model class for ReflectionSet
    """
    def __init__(self, **data: Any) -> None:
        super().__init__(**data)
        MxlimsImplementation.__init__(self)
        
    mxlims_base_type: Literal["Dataset"] = Field(
        "Dataset",
        alias="mxlimsBaseType",
        description="The abstract (super)type of MXLIMS object.",
        title="MxlimsBaseType",
        exclude=True,
        frozen=True
    )
    mxlims_type: Literal["ReflectionSet"] = Field(
        "ReflectionSet",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="MxlimsType",
        frozen=True,
    )
    uuid: Optional[UUID] = Field(
        default_factory=uuid1,
        description="Permanent unique identifier string",
        title="Uuid",
        frozen=True
    )
    
    @property
    def derived_datasets(self) -> list[ReflectionSet]:
        """getter for ReflectionSet.derived_datasets list"""
        return self._get_link_1n("Dataset", "derived_from_id")

    @property
    def derived_from(self) -> Optional[ReflectionSet]:
        """getter for ReflectionSet.derived_from"""
        return self._get_link_n1("Dataset", "derived_from_id")

    @property
    def logistical_sample(self) -> Optional[Union[Crystal, DropRegion, Pin, PinPosition, PlateWell, WellDrop]]:
        """getter for ReflectionSet.logistical_sample"""
        return self._get_link_n1("LogisticalSample", "logistical_sample_id")

    @logistical_sample.setter
    def logistical_sample(self, value: Optional[Union[Crystal, DropRegion, Pin, PinPosition, PlateWell, WellDrop]]):
        """setter for ReflectionSet.logistical_sample"""
        from .Crystal import Crystal
        from .Pin import Pin
        from .PinPosition import PinPosition
        from .PlateWell import PlateWell
        from .WellDrop import WellDrop
        from .DropRegion import DropRegion

        if value is None or isinstance(value, Union[Crystal, DropRegion, Pin, PinPosition, PlateWell, WellDrop]):
            self._set_link_n1("LogisticalSample", "logistical_sample_id", value)
        else:
            raise ValueError("logistical_sample must be of type Union[Crystal, DropRegion, Pin, PinPosition, PlateWell, WellDrop] or None")

    @property
    def reference_for(self) -> list[Union[MxExperiment, MxProcessing]]:
        """getter for ReflectionSet.reference_for list"""
        return self._get_link_nn_rev("Job", "reference_data_ids")

    @reference_for.setter
    def reference_for(self, values: list[Union[MxExperiment, MxProcessing]]):
        """setter for ReflectionSet.reference_for list"""
        from .MxExperiment import MxExperiment
        from .MxProcessing import MxProcessing

        for obj in values:
            if not isinstance(obj, Union[MxExperiment, MxProcessing]):
                raise ValueError("%s is not of type Union[MxExperiment, MxProcessing]" % obj)
        self._set_link_nn_rev("Job", "reference_data_ids", values)

    def append_reference_for(self, value: Union[MxExperiment, MxProcessing]):
        """append to ReflectionSet.reference_for list"""
        value.append_reference_data(self)

    def remove_reference_for(self, value: Union[MxExperiment, MxProcessing]):
        """remove from ReflectionSet.reference_for list"""
        value.remove_reference_data(self)
    
    @property
    def source(self) -> Optional[MxProcessing]:
        """getter for ReflectionSet.source"""
        return self._get_link_n1("Job", "source_id")

    @property
    def template_for(self) -> list[MxProcessing]:
        """getter for ReflectionSet.template_for list"""
        return self._get_link_nn_rev("Job", "template_data_ids")

    @template_for.setter
    def template_for(self, values: list[MxProcessing]):
        """setter for ReflectionSet.template_for list"""
        from .MxProcessing import MxProcessing

        for obj in values:
            if not isinstance(obj, MxProcessing):
                raise ValueError("%s is not of type MxProcessing" % obj)
        self._set_link_nn_rev("Job", "template_data_ids", values)

    def append_template_for(self, value: MxProcessing):
        """append to ReflectionSet.template_for list"""
        value.append_template_data(self)

    def remove_template_for(self, value: MxProcessing):
        """remove from ReflectionSet.template_for list"""
        value.remove_template_data(self)
    