# generated by mxlims/impl/generate_code.py
#  filename MxProcessing.py

# NB Literal and UUID have to be imported to avoid pydantic errors
from __future__ import annotations
from typing import Any, Literal, Optional, Union, TYPE_CHECKING
from uuid import UUID
from mxlims.impl.MxlimsBase import MxlimsImplementation
from ..core.Job import Job
from ..data.JobData import JobData
from ..data.MxProcessingData import MxProcessingData
if TYPE_CHECKING:
    from .CollectionSweep import CollectionSweep
    from .Crystal import Crystal
    from .CrystallographicSample import CrystallographicSample
    from .DropRegion import DropRegion
    from .Pin import Pin
    from .PinPosition import PinPosition
    from .PlateWell import PlateWell
    from .ReflectionSet import ReflectionSet
    from .WellDrop import WellDrop

class MxProcessing(MxProcessingData, JobData, Job, MxlimsImplementation):
    """MXLIMS pydantic model class for MxProcessing
    """
    def __init__(self, **data: Any) -> None:
        super().__init__(**data)
        MxlimsImplementation.__init__(self)
    
    @property
    def input_data(self) -> list[CollectionSweep]:
        """getter for MxProcessing.input_data list"""
        return self._get_link_nn("Dataset", "input_data_ids")

    @input_data.setter
    def input_data(self, values: list[CollectionSweep]):
        """setter for MxProcessing.input_data list"""
        from .CollectionSweep import CollectionSweep

        for obj in values:
            if not isinstance(obj, CollectionSweep):
                raise ValueError("%s is not of type CollectionSweep" % obj)
        self._set_link_nn("Dataset", "input_data_ids", values)

    def append_input_data(self, value: CollectionSweep):
        """append to MxProcessing.input_data list"""
        from .CollectionSweep import CollectionSweep

        if isinstance(value, CollectionSweep):
            self._append_link_nn("input_data_ids", value)
        else:
            raise ValueError("%s is not of type CollectionSweep" % value)

    def remove_input_data(self, value: CollectionSweep):
        """remove from MxProcessing.input_data list"""
        from .CollectionSweep import CollectionSweep

        if isinstance(value, CollectionSweep):
            self._remove_link_nn("input_data_ids", value)
        else:
            raise ValueError("%s is not of type CollectionSweep" % value)

    @property
    def logistical_sample(self) -> Optional[Union[Crystal, DropRegion, Pin, PinPosition, PlateWell, WellDrop]]:
        """getter for MxProcessing.logistical_sample"""
        return self._get_link_n1("LogisticalSample", "logistical_sample_id")

    @logistical_sample.setter
    def logistical_sample(self, value: Optional[Union[Crystal, DropRegion, Pin, PinPosition, PlateWell, WellDrop]]):
        """setter for MxProcessing.logistical_sample"""
        from .Crystal import Crystal
        from .Pin import Pin
        from .PinPosition import PinPosition
        from .PlateWell import PlateWell
        from .WellDrop import WellDrop
        from .DropRegion import DropRegion

        if value is None or isinstance(value, Union[Crystal, DropRegion, Pin, PinPosition, PlateWell, WellDrop]):
            self._set_link_n1("LogisticalSample", "logistical_sample_id", value)
        else:
            raise ValueError("logistical_sample must be of type Union[Crystal, DropRegion, Pin, PinPosition, PlateWell, WellDrop] or None")

    @property
    def reference_data(self) -> list[ReflectionSet]:
        """getter for MxProcessing.reference_data list"""
        return self._get_link_nn("Dataset", "reference_data_ids")

    @reference_data.setter
    def reference_data(self, values: list[ReflectionSet]):
        """setter for MxProcessing.reference_data list"""
        from .ReflectionSet import ReflectionSet

        for obj in values:
            if not isinstance(obj, ReflectionSet):
                raise ValueError("%s is not of type ReflectionSet" % obj)
        self._set_link_nn("Dataset", "reference_data_ids", values)

    def append_reference_data(self, value: ReflectionSet):
        """append to MxProcessing.reference_data list"""
        from .ReflectionSet import ReflectionSet

        if isinstance(value, ReflectionSet):
            self._append_link_nn("reference_data_ids", value)
        else:
            raise ValueError("%s is not of type ReflectionSet" % value)

    def remove_reference_data(self, value: ReflectionSet):
        """remove from MxProcessing.reference_data list"""
        from .ReflectionSet import ReflectionSet

        if isinstance(value, ReflectionSet):
            self._remove_link_nn("reference_data_ids", value)
        else:
            raise ValueError("%s is not of type ReflectionSet" % value)

    @property
    def results(self) -> list[ReflectionSet]:
        """getter for MxProcessing.results list"""
        return self._get_link_1n("Dataset", "source_id")

    @property
    def sample(self) -> Optional[CrystallographicSample]:
        """getter for MxProcessing.sample"""
        return self._get_link_n1("PreparedSample", "sample_id")

    @sample.setter
    def sample(self, value: Optional[CrystallographicSample]):
        """setter for MxProcessing.sample"""
        from .CrystallographicSample import CrystallographicSample

        if value is None or isinstance(value, CrystallographicSample):
            self._set_link_n1("PreparedSample", "sample_id", value)
        else:
            raise ValueError("sample must be of type CrystallographicSample or None")

    @property
    def started_from(self) -> Optional[MxProcessing]:
        """getter for MxProcessing.started_from"""
        return self._get_link_n1("Job", "started_from_id")

    @property
    def subjobs(self) -> list[MxProcessing]:
        """getter for MxProcessing.subjobs list"""
        return self._get_link_1n("Job", "started_from_id")

    @property
    def template_data(self) -> list[ReflectionSet]:
        """getter for MxProcessing.template_data list"""
        return self._get_link_nn("Dataset", "template_data_ids")

    @template_data.setter
    def template_data(self, values: list[ReflectionSet]):
        """setter for MxProcessing.template_data list"""
        from .ReflectionSet import ReflectionSet

        for obj in values:
            if not isinstance(obj, ReflectionSet):
                raise ValueError("%s is not of type ReflectionSet" % obj)
        self._set_link_nn("Dataset", "template_data_ids", values)

    def append_template_data(self, value: ReflectionSet):
        """append to MxProcessing.template_data list"""
        from .ReflectionSet import ReflectionSet

        if isinstance(value, ReflectionSet):
            self._append_link_nn("template_data_ids", value)
        else:
            raise ValueError("%s is not of type ReflectionSet" % value)

    def remove_template_data(self, value: ReflectionSet):
        """remove from MxProcessing.template_data list"""
        from .ReflectionSet import ReflectionSet

        if isinstance(value, ReflectionSet):
            self._remove_link_nn("template_data_ids", value)
        else:
            raise ValueError("%s is not of type ReflectionSet" % value)
