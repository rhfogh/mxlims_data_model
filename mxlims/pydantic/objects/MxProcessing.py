# generated by mxlims/scripts
#  filename MxProcessing.py

from __future__ import annotations
from typing import Optional, Union
from ..core.Job import Job
from ..data.JobData import JobData
from ..data.MxProcessingData import MxProcessingData
from .CollectionSweep import CollectionSweep
from .Crystal import Crystal
from .CrystallographicSample import CrystallographicSample
from .DropRegion import DropRegion
from .Pin import Pin
from .PinPosition import PinPosition
from .PlateWell import PlateWell
from .ReflectionSet import ReflectionSet
from .WellDrop import WellDrop

class MxProcessing(MxProcessingData, JobData, Job):
    """MXLIMS pydantic model class for MxProcessing
    """
    
    @property
    def input_data(self) -> list[CollectionSweep]:
        """getter for MxProcessing.input_data list"""
        result = []
        for uid in self.input_data_ids:
            obj = self.objects_by_id["Dataset"].get(uid)
            if obj:
                result.append(obj)
        return result
    
    @input_data.setter
    def input_data(self, value: list[CollectionSweep]):
        """setter for MxProcessing.input_data list"""
        uids = []
        for obj in value:
            if isinstance(obj, CollectionSweep):
                uids.append(obj.uuid)
            else:
                raise ValueError("%s is not of type CollectionSweep" % value)
        self.input_data_ids = uids

    def append_input_data(self, value: CollectionSweep):
        """append to MxProcessing.input_data list"""
        if isinstance(value, CollectionSweep):
            uid = value.uuid
            if uid in self.input_data_ids:
                raise ValueError("%s is already in MxProcessing.input_data" % value)
            else:
                self.input_data_ids.append(uid)
        else:
            raise ValueError("%s is not of type CollectionSweep" % value)

    def remove_input_data(self, value: CollectionSweep):
        """remove from MxProcessing.input_data list"""
        if isinstance(value, CollectionSweep):
            uid = value.uuid
            if uid in self.input_data_ids:
                self.input_data_ids.remove(uid)
            else:
                raise ValueError("Input %s not found" % value)
        else:
            raise ValueError("%s is not of type CollectionSweep" % value)

    @property
    def logistical_sample(self) -> Optional[Union[Crystal, DropRegion, Pin, PinPosition, PlateWell, WellDrop]]:
        """getter for MxProcessing.logistical_sample"""
        return self.objects_by_id["LogisticalSample"].get(self.logistical_sample_id)
    
    @logistical_sample.setter
    def logistical_sample(self, value: Optional[Union[Crystal, DropRegion, Pin, PinPosition, PlateWell, WellDrop]]):
        """setter for MxProcessing.logistical_sample"""
        if value:
            if not isinstance(value, Union[Crystal, DropRegion, Pin, PinPosition, PlateWell, WellDrop]):
                raise ValueError(
                    "logistical_sample must be of type Union[Crystal, DropRegion, Pin, PinPosition, PlateWell, WellDrop]"
                )
            self.logistical_sample_id = value.uuid
        else:
            self.logistical_sample_id = None

    @property
    def reference_data(self) -> list[ReflectionSet]:
        """getter for MxProcessing.reference_data list"""
        result = []
        for uid in self.reference_data_ids:
            obj = self.objects_by_id["Dataset"].get(uid)
            if obj:
                result.append(obj)
        return result
    
    @reference_data.setter
    def reference_data(self, value: list[ReflectionSet]):
        """setter for MxProcessing.reference_data list"""
        uids = []
        for obj in value:
            if isinstance(obj, ReflectionSet):
                uids.append(obj.uuid)
            else:
                raise ValueError("%s is not of type ReflectionSet" % value)
        self.reference_data_ids = uids

    def append_reference_data(self, value: ReflectionSet):
        """append to MxProcessing.reference_data list"""
        if isinstance(value, ReflectionSet):
            uid = value.uuid
            if uid in self.reference_data_ids:
                raise ValueError("%s is already in MxProcessing.reference_data" % value)
            else:
                self.reference_data_ids.append(uid)
        else:
            raise ValueError("%s is not of type ReflectionSet" % value)

    def remove_reference_data(self, value: ReflectionSet):
        """remove from MxProcessing.reference_data list"""
        if isinstance(value, ReflectionSet):
            uid = value.uuid
            if uid in self.reference_data_ids:
                self.reference_data_ids.remove(uid)
            else:
                raise ValueError("Input %s not found" % value)
        else:
            raise ValueError("%s is not of type ReflectionSet" % value)

    @property
    def results(self) -> list[ReflectionSet]:
        """getter for MxProcessing.results list"""
        uid = self.uuid
        result = []
        for obj in self.objects_by_id["Dataset"]:
            if uid == obj.source_id:
                result.append(obj)
        return result
    
    @property
    def sample(self) -> Optional[CrystallographicSample]:
        """getter for MxProcessing.sample"""
        return self.objects_by_id["PreparedSample"].get(self.sample_id)
    
    @sample.setter
    def sample(self, value: Optional[CrystallographicSample]):
        """setter for MxProcessing.sample"""
        if value:
            if not isinstance(value, CrystallographicSample):
                raise ValueError(
                    "sample must be of type CrystallographicSample"
                )
            self.sample_id = value.uuid
        else:
            self.sample_id = None

    @property
    def started_from(self) -> Optional[MxProcessing]:
        """getter for MxProcessing.started_from"""
        return self.objects_by_id["Job"].get(self.started_from_id)
    
    @property
    def subjobs(self) -> list[MxProcessing]:
        """getter for MxProcessing.subjobs list"""
        uid = self.uuid
        result = []
        for obj in self.objects_by_id["Job"]:
            if uid == obj.started_from_id:
                result.append(obj)
        return result
    
    @property
    def template_data(self) -> list[ReflectionSet]:
        """getter for MxProcessing.template_data list"""
        result = []
        for uid in self.template_data_ids:
            obj = self.objects_by_id["Dataset"].get(uid)
            if obj:
                result.append(obj)
        return result
    
    @template_data.setter
    def template_data(self, value: list[ReflectionSet]):
        """setter for MxProcessing.template_data list"""
        uids = []
        for obj in value:
            if isinstance(obj, ReflectionSet):
                uids.append(obj.uuid)
            else:
                raise ValueError("%s is not of type ReflectionSet" % value)
        self.template_data_ids = uids

    def append_template_data(self, value: ReflectionSet):
        """append to MxProcessing.template_data list"""
        if isinstance(value, ReflectionSet):
            uid = value.uuid
            if uid in self.template_data_ids:
                raise ValueError("%s is already in MxProcessing.template_data" % value)
            else:
                self.template_data_ids.append(uid)
        else:
            raise ValueError("%s is not of type ReflectionSet" % value)

    def remove_template_data(self, value: ReflectionSet):
        """remove from MxProcessing.template_data list"""
        if isinstance(value, ReflectionSet):
            uid = value.uuid
            if uid in self.template_data_ids:
                self.template_data_ids.remove(uid)
            else:
                raise ValueError("Input %s not found" % value)
        else:
            raise ValueError("%s is not of type ReflectionSet" % value)
