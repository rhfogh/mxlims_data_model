# generated by mxlims/scripts
#  filename Crystal.py

from __future__ import annotations
from typing import Optional, Union
from ..core.LogisticalSample import LogisticalSample
from ..data.LogisticalSampleData import LogisticalSampleData
from ..data.CrystalData import CrystalData
from .CollectionSweep import CollectionSweep
from .CrystallographicSample import CrystallographicSample
from .DropRegion import DropRegion
from .MxExperiment import MxExperiment
from .MxProcessing import MxProcessing
from .PinPosition import PinPosition
from .ReflectionSet import ReflectionSet

class Crystal(CrystalData, LogisticalSampleData, LogisticalSample):
    """MXLIMS pydantic model class for Crystal
    """
    
    @property
    def container(self) -> Optional[Union[DropRegion, PinPosition]]:
        """getter for Crystal.container"""
        return self.objects_by_id["LogisticalSample"].get(self.container_id)
    
    @container.setter
    def container(self, value: Optional[Union[DropRegion, PinPosition]]):
        """setter for Crystal.container"""
        if value:
            if not isinstance(value, Union[DropRegion, PinPosition]):
                raise ValueError(
                    "container must be of type Union[DropRegion, PinPosition]"
                )
            self.container_id = value.uuid
        else:
            self.container_id = None

    @property
    def datasets(self) -> list[Union[CollectionSweep, ReflectionSet]]:
        """getter for Crystal.datasets list"""
        uid = self.uuid
        result = []
        for obj in self.objects_by_id["Dataset"]:
            if uid == obj.logistical_sample_id:
                result.append(obj)
        return result
    
    @property
    def jobs(self) -> list[Union[MxExperiment, MxProcessing]]:
        """getter for Crystal.jobs list"""
        uid = self.uuid
        result = []
        for obj in self.objects_by_id["Job"]:
            if uid == obj.logistical_sample_id:
                result.append(obj)
        return result
    
    @property
    def sample(self) -> Optional[CrystallographicSample]:
        """getter for Crystal.sample"""
        return self.objects_by_id["PreparedSample"].get(self.sample_id)
    
    @sample.setter
    def sample(self, value: Optional[CrystallographicSample]):
        """setter for Crystal.sample"""
        if value:
            if not isinstance(value, CrystallographicSample):
                raise ValueError(
                    "sample must be of type CrystallographicSample"
                )
            self.sample_id = value.uuid
        else:
            self.sample_id = None
