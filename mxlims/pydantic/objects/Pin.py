# generated by mxlims/impl/generate_code.py
#  filename Pin.py

# NB UUID has to be imported to avoid pydantic errors ??
from __future__ import annotations
from pydantic import Field
from typing import Any, Literal, Optional, Union, TYPE_CHECKING
# from uuid import UUID, uuid1
from ..objects.LogisticalSample import LogisticalSample
from ..data.PinData import PinData
if TYPE_CHECKING:
    from .CollectionSweep import CollectionSweep
    from .Crystal import Crystal
    from .MacromoleculeSample import MacromoleculeSample
    from .MxExperiment import MxExperiment
    from .MxProcessing import MxProcessing
    from .Puck import Puck
    from .ReflectionSet import ReflectionSet

class Pin(PinData, LogisticalSample):
    """MXLIMS pydantic model class for Pin
    """
    def __init__(self, **data: Any) -> None:
        super().__init__(**data)
        
    mxlims_type: Literal["Pin"] = Field(
        "Pin",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="MxlimsType",
        frozen=True,
    )
    
    @property
    def container(self) -> Optional[Puck]:
        """getter for Pin.container"""
        return self._get_link_n1("LogisticalSample", "container_id")

    @container.setter
    def container(self, value: Optional[Puck]):
        """setter for Pin.container"""
        from .Puck import Puck

        if value is None or isinstance(value, Puck):
            self._set_link_n1("LogisticalSample", "container_id", value)
        else:
            raise ValueError("container must be of type Puck or None")

    @property
    def contents(self) -> list[Crystal]:
        """getter for Pin.contents list"""
        return self._get_link_1n("LogisticalSample", "container_id")

    @contents.setter
    def contents(self, values: list[Crystal]):
        """setter for Pin.contents list"""
        from .Crystal import Crystal

        for obj in values:
            if not isinstance(obj, Crystal):
                raise ValueError("%s is not of type Crystal" % obj)
        self._set_link_1n_rev("LogisticalSample", "container_id", values)

    @property
    def datasets(self) -> list[Union[CollectionSweep, ReflectionSet]]:
        """getter for Pin.datasets list"""
        return self._get_link_1n("Dataset", "logistical_sample_id")

    @datasets.setter
    def datasets(self, values: list[Union[CollectionSweep, ReflectionSet]]):
        """setter for Pin.datasets list"""
        from .ReflectionSet import ReflectionSet
        from .CollectionSweep import CollectionSweep

        for obj in values:
            if not isinstance(obj, Union[CollectionSweep, ReflectionSet]):
                raise ValueError("%s is not of type Union[CollectionSweep, ReflectionSet]" % obj)
        self._set_link_1n_rev("Dataset", "logistical_sample_id", values)

    @property
    def jobs(self) -> list[Union[MxExperiment, MxProcessing]]:
        """getter for Pin.jobs list"""
        return self._get_link_1n("Job", "logistical_sample_id")

    @jobs.setter
    def jobs(self, values: list[Union[MxExperiment, MxProcessing]]):
        """setter for Pin.jobs list"""
        from .MxExperiment import MxExperiment
        from .MxProcessing import MxProcessing

        for obj in values:
            if not isinstance(obj, Union[MxExperiment, MxProcessing]):
                raise ValueError("%s is not of type Union[MxExperiment, MxProcessing]" % obj)
        self._set_link_1n_rev("Job", "logistical_sample_id", values)

    @property
    def sample(self) -> Optional[MacromoleculeSample]:
        """getter for Pin.sample"""
        return self._get_link_n1("Sample", "sample_id")

    @sample.setter
    def sample(self, value: Optional[MacromoleculeSample]):
        """setter for Pin.sample"""
        from .MacromoleculeSample import MacromoleculeSample

        if value is None or isinstance(value, MacromoleculeSample):
            self._set_link_n1("Sample", "sample_id", value)
        else:
            raise ValueError("sample must be of type MacromoleculeSample or None")
