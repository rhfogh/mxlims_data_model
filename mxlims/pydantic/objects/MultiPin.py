# generated by mxlims/impl/generate_code.py
#  filename MultiPin.py

from __future__ import annotations
from pydantic import ConfigDict, Field
from typing import Any, Literal, Optional, Union, TYPE_CHECKING
from ..objects.LogisticalSample import LogisticalSample
from ..data.MultiPinData import MultiPinData
if TYPE_CHECKING:
    from .PinPosition import PinPosition
    from .Puck import Puck

class MultiPin(MultiPinData, LogisticalSample):
    """MXLIMS pydantic model class for MultiPin
    """
        
    mxlims_type: Literal["MultiPin"] = Field(
        "MultiPin",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="MxlimsType",
        frozen=True,
    )
    
    model_config = ConfigDict(
        extra="forbid",
    )
        
    @property
    def container(self) -> Optional[Puck]:
        """getter for MultiPin.container"""
        return self._get_link_n1("LogisticalSample", "container_id")

    @container.setter
    def container(self, value: Optional[Puck]):
        """setter for MultiPin.container"""
        from .Puck import Puck

        if value is None or isinstance(value, Puck):
            self._set_link_n1("LogisticalSample", "container_id", value)
        else:
            raise ValueError("container must be of type Puck or None")

    @property
    def contents(self) -> list[PinPosition]:
        """getter for MultiPin.contents list"""
        return self._get_link_1n("LogisticalSample", "container_id")

    @contents.setter
    def contents(self, values: list[PinPosition]):
        """setter for MultiPin.contents list"""
        from .PinPosition import PinPosition

        for obj in values:
            if not isinstance(obj, PinPosition):
                raise ValueError("%s is not of type PinPosition" % obj)
        self._set_link_1n_rev("LogisticalSample", "container_id", values)
