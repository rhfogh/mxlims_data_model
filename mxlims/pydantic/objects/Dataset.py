# generated by mxlims/impl/generate_code.py
#  filename Dataset.py

from __future__ import annotations
from pydantic import Field, model_validator
from typing import List, Literal, Optional, TYPE_CHECKING
from uuid import UUID, uuid1
from mxlims.core.MxlimsObject import MxlimsObject
from ..data.DatasetData import DatasetData
if TYPE_CHECKING:
    from .Job import Job
    from .LogisticalSample import LogisticalSample
    from typing_extensions import Self

class Dataset(DatasetData, MxlimsObject):
    """MXLIMS pydantic model class for Dataset
    """
        
    mxlims_base_type: Literal["Dataset"] = Field(
        "Dataset",
        alias="mxlimsBaseType",
        description="The abstract (super)type of MXLIMS object.",
        title="MxlimsBaseType",
        exclude=True,
        frozen=True
    )
    mxlims_type: str = Field(
        "Dataset",
        alias="mxlimsType",
        description="The type of MXLIMS object.",
        title="MxlimsType",
        frozen=True,
    )
    uuid: Optional[UUID] = Field(
        default_factory=uuid1,
        description="Permanent unique identifier string",
        title="Uuid",
        frozen=True
    )

    source_id: Optional[UUID] = Field(
        None, alias="sourceId", description="uuid for Dataset source", title="SourceId"
    )
    derived_from_id: Optional[UUID] = Field(
        None,
        alias="derivedFromId",
        description="uuid for Dataset from which Dataset is derived",
        title="DerivedFromId",
    )
    logistical_sample_id: Optional[UUID] = Field(
        None,
        alias="logisticalSampleId",
        description="uuid for LogisticalSample related to Dataset",
        title="LogisticalSampleId",
    )
    @property
    def derived_datasets(self) -> list[Dataset]:
        """Abstract superclass - dummy getter for Dataset.derived_datasets list"""
        return []

    @property
    def derived_from(self) -> Optional[Dataset]:
        """Abstract superclass - dummy getter for Dataset.derived_from"""
        return None

    @property
    def input_for(self) -> list[Job]:
        """Abstract superclass - dummy getter for Dataset.input_for list"""
        return []

    @property
    def logistical_sample(self) -> Optional[LogisticalSample]:
        """Abstract superclass - dummy getter for Dataset.logistical_sample"""
        return None

    @property
    def reference_for(self) -> list[Job]:
        """Abstract superclass - dummy getter for Dataset.reference_for list"""
        return []

    @property
    def source(self) -> Optional[Job]:
        """Abstract superclass - dummy getter for Dataset.source"""
        return None

    @property
    def template_for(self) -> list[Job]:
        """Abstract superclass - dummy getter for Dataset.template_for list"""
        return []

    @model_validator(mode='after')
    def source_and_derivedFrom_are_mutually_exclusive(self) -> Self:
        if self.source_id is not None and self.derived_from_id is not None:
            raise ValueError("source and derivedFrom are mutually exclusive")
        return self
